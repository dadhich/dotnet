Build Image

docker build . -t abhi/exampleapp -f Dockerfile

The docker build command creates a new image. The period that follows the build keyword provides the context, which is the location that is used for commands such as COPY in the Docker file. The -t argument tags the new image as abhi/exampleapp, and the -f argument specifies the Docker file that contains the instructions for creating the image. (The convention for naming images is to use your name or your organization’s name, followed by the application name.)

--

Create Container

docker create -p 3000:80 --name exampleApp3000 abhi/exampleapp

The docker create command is used to create a new container.
The -p argument to the docker create command tells Docker how to map port 80 inside the container to the host operating system. In this case, I have specified that port 80 inside the container should be mapped to port 3000 in the host operating system. This corresponds to the EXPOSE command in the Docker file.
The --name argument assigns a name to the container, which makes it easier to work with once it has been created. The name in this case is exampleApp3000, indicating that this container will respond to requests sent to port 3000 in the host operating system.
The final argument tells Docker which image to use as the template for the new container. This command specifies the abhi/exampleapp image, which is the name used with the docker build command

--

Start Container

docker start exampleApp3000

Docker will use the ENTRYPOINT command from the Docker file to start the application in the container.

In this case, that means the .NET Core runtime is started, followed by the ASP.NET Core Kestrel server, which will listen for incoming HTTP requests on port 80 inside the container. As the container is started, Docker will also set up the port mapping so that network traffic received on port 3000 on the host operating system will be directed to port 80 inside the container, allowing Kestrel to receive HTTP requests from outside the container.
To test the container, open a new browser window and request the URL http://localhost:3000, which will send an HTTP request to port 3000 on the host operating system. Docker will direct the request to port 80 inside the container, which allows it to be received by Kestrel, which will start ASP.NET Core MVC and run the example application.

--

Starting All Containers

docker start $(docker ps -aq)

The command combines docker start with the output of the docker ps command. The -a argument includes containers that are not running, and the -q argument returns just the container IDs.

--

Creating and Starting Containers with a Single Command

The docker run command is used to create a container from an image and start it in a single step, combining the effects of the docker create and docker start commands. Run the command to create and start a container from the custom image, with a port mapping that forwards network traffic from port 5000 in the host operating system to port 80 inside the container.

docker run -p 5000:80 --name exampleApp5000 abhi/exampleapp

This command takes the same arguments as the docker create command from Listing 4-10: it tells Docker to create the container from the abhi/exampleapp image, sets up the port mapping, and assigns the container the name exampleApp5000. The difference is that the container is started once it has been created. The docker run command keeps the command prompt attached to the container output so that the messages generated by the Kestrel server are displayed in the command prompt.

The docker run command can be used with the --rm argument, which tells Docker to remove the container when it stops. Run this command to create a container that maps port 6500 in the host container to port 80 in the new container:

docker run -p 6500:80 --rm --name exampleApp6500 abhi/exampleapp

--

Listing Containers

docker ps

docker ps -a

The docker ps command is used to list the containers that exist on a system. By default, the docker ps command omits containers that are not running, so the -a argument must be used if you want to see all the containers that are available

--

Stopping Containers

docker stop exampleApp3000

Run the command shown in Listing 4-15 to stop all the running containers, using the list of containers generated by the docker ps command.

Stopping All Containers

docker stop $(docker ps -q)

The only argument required for the docker ps command is -q. The -a argument is not used because only the IDs of running containers are needed for the stop command, and this is what the ps command returns by default.

--

Getting Container Output

By default, Docker doesn’t display the output from the application when you start a container using the docker start command. But it does keep a record that can be inspected using the docker logs command, as shown:

docker logs exampleApp3000

--